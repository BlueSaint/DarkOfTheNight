package Client

// ---------------

import LinkedList

// ---------------

/** used to catch various client-related events */
public interface ClientEvent
	function execute(Client c)

// ---------------

LinkedList<ClientEvent> onClientLeave	= new LinkedList<ClientEvent>

function LinkedList<ClientEvent>.execute(Client c)
	for ClientEvent e in this
		e.execute(c)

/** if a client leaves, given function will be run */
public function registerOnClientLeave(ClientEvent e)
	onClientLeave.add(e)

// ---------------

/** client means human player */
public class Client

	/** local client 
	obvious desync warning */
	static Client lcl
	
	/** player handle */
	player p
	
	private trigger dt
	
	/** prints a message for the client to see */	
	function print(string msg,real dur)
		printTimedToPlayer(msg,dur,p)
	
	construct(player p)
		this.p		= p
		this.dt		= CreateTrigger()
		dt.registerPlayerEvent(p,EVENT_PLAYER_LEAVE)
		dt.addCondition(Condition(function onClientLeave))
		
	ondestroy
		onClientLeave.execute(this)
		dt.destr()

// ---------------

public constant LinkedList<Client> clients = new LinkedList<Client>
public function playerToClient(player p) returns Client
	for Client c in clients
		if c.p==p
			return c
	return null

function onClientLeave() returns boolean
	let c=playerToClient(GetTriggerPlayer())
	Client.lcl.print(c.p.getNameColored()+" has left the game",15)
	clients.remove(c)
	destroy c
	return false

// ---------------

init
	let lcl=GetLocalPlayer()
	for int i=0 to 11
		let p=Player(i)
		
		if	p.getController()==MAP_CONTROL_USER
			and p.getSlotState()==PLAYER_SLOT_STATE_PLAYING
			
			clients.addtoStart(new Client(p))
			if p==lcl
				Client.lcl=clients.get(0)