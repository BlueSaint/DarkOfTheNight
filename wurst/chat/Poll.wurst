package Poll

import Client
import LinkedList
		
// ---------------

/** polls call these functions when that certain event occurs */
interface DialogEvents
	/** completely finished */
	function finish()
		
	/** finished for client */
	function finish(Client c)
		
	/** timeout occured for client */
	function timeout(Client c)
		
// ---------------

/** base class for polls */
public abstract class Poll
	DialogEvents ev
	
	timer timeout
	
	LinkedList<Client> targets
	
	/** adds client so she/he can cast vote */
	function addClient(Client c)
		if timeout!=null
			error("Please init clients before timeout")
		targets.add(c)
		
	ondestroy
		ev.finish()
		if timeout!=null
			timeout.release()
		destroy targets
		
	protected function doTimeout()
		for Client c in targets
			ev.timeout(c)
		destroy this
	
	/** poll will expire after given amount of time */
	function addTimeout(real time)
		if timeout!=null
			error("Timer already present")
		timeout	= getTimer()
		..setData(this castTo int)
		..start(time,() -> begin
			(GetExpiredTimer().getData() castTo DialogPoll).doTimeout()
		end)
		
	construct(DialogEvents ev)
		this.ev			= ev
		this.targets	= new LinkedList<Client>
		timeout			= null
		
// ---------------

/** dialog-based poll (requires attention) */
public class DialogPoll extends Poll
	private dialog d
	private trigger dt
	
	/** adds client so she/he can cast vote */
	override function addClient(Client c)
		super.addClient(c)
		DialogDisplay(c.p,d,true)
	
	ondestroy
		DialogDestroy(d)
		
	private override function doTimeout()
		for Client c in targets
			DialogDisplay(c.p,d,false)
		super.doTimeout()
	
	construct(DialogEvents ev)
		super(ev)
		dialog d	= DialogCreate()